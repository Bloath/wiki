# makefile相关

> makefile是在linux编程中不可或缺的一部分，对于简单的文件来讲，其规则比较简单，往往几行就可以完成编译，但是对于层级较多，文件多，功能较为复杂的应用来讲，就需要一些技巧来完成编译，这篇笔记就是对于在实际发生的一些问题如何解决来引申



[TOC]

## 1. 通配编译

**问题**：在对多文件进行编译时，在新的文件添加进来时，不可能每次都进行手动修改，添加对应文件的编译目标以及添加输出结果的依赖

**解决**：通配处理，分成两部分

* 所以相似依赖的统一处理

  ```
  %.o: %.c
  	$(CC) -c $^ -o $@
  	
  %: 通配
  $^：所有依赖文件
  $@：目标文件
  ```



## 2. 自动找到依赖

问题：如果我们将代码做的比较分散的时候，即模块化编程的时候，对于不同的层级，其依赖关系我们很难手动更改，就需要自动生成依赖

解决：通过GCC本身的 -MM 选项

详情：

```
arm-linux-gcc -MM hardware/dps310.c
>>> dps310.o: hardware/dps310.c hardware/dps310.h hardware/i2c.h
```

通过这条命令就得出了该文件的依赖关系，这个依赖关系就可以作为makefile的目标

那么makefile如何动态的生成并使用依赖？就需要

* 将所需要生成的目标文件添加到**目的列表**中
* 将**目的列表**文件列表后缀改为**依赖文件**后缀（`xx.d`）通过`include `关键字添加到makefile中
* 添加**依赖文件**的生成规则添加到makfile中

```makefile
 
# 依赖文件的生成规则
%.d : %.c
	@set -e; \
	$(CC) -MM $< > $@.$$$$; \
	sed 's,\($*\)\.o[ :]*,\1.o $@ : ,g' < $@.$$$$ > $@; \
	rm -f $@.$$$$

```





## 2. 多文件夹层级的编译

> 对于多文件夹层级的编译，基本上也是走通配的方法，相当于我匹配了文件的完整路径

```
%.o: %.c
	$(CC) -c $^ -o $@
```

这种方法只能适配与makefile同级的目标文件，如何加入文件路径呢，就需要makefile的下面两个函数

* wildcard：`$(wildcard *.c ./foo/*.c)`，搜索当前目录以及foo目录下的所有.c文件，并生成空格间隔的字符串
* patsubst：`$(patsubst %.c %.o $(SRC)) `，将SRC变量当中的所有.c结果的转换为.o

用上述两个方法就可以添加不同路径下的目标文件了

```
假设目录中有
```

